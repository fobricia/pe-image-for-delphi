= Introduction =

*PEImage* library can be used to parse and modify 32/64 bit executable images. Image can be loaded from stream, file or from mapped image.

The library is part of [http://vdisasm.com/ VDisAsm Project]

Also it can make simple image building/rebuilding. But it's rather experimental.


= Supported features =

== It can load image ==

  * from file
  * from stream
  * from mapped image (i.e. from module in current process address space, like ntdll)

== It can parse ==

  * 32/64 bit images. You don't need to worry about field sizes.
  * exports
  * imports
  * relocations
  * thread local storage table
  * long section names from COFF table
  * resources (raw only right now)
  * exception records in .pdata section (useful for example for ARM executables)
  * overlay functions
    * extract to file
    * delete
    * append to other file
  * address conversion between virtual address and relative virtual address.

== Selective parsing ==

You can specify what stage to parse. For example, you can tell it to load only base image and not to waste time for parsing other elements. Or you can specify combination of things to load (exports+imports+relocs...)

== Rebuilding image parts ==

Units PE.Build.??? are responsible for building image directory data. Currently supported:

  * export
  * import

== Saving ==

You can modify image and save it to file or stream. It's easy way to make some patches programmatically.

Also you can dump only needed part, like section, overlay, resource.

== DLL Loading ==

Parsed image can be loaded as executable image in similar way Windows Loader does. It works only for DLLs. Don't try to load EXEs this way.

== Code analysis ==

  * PE.Image.x86 unit
    * searching relative jumps and calls in sections

== Portability ==

It was written with portability in mind and uses minimum platform dependency. So you can build library for

  * Win32, Win64
  * OS X
  * other platforms to be supported by Delphi


== Usage examples ==

The library can be used for

  * learning PE format
  * creating packers or protectors
  * creating unpackers
  * creating linker for your compiler
  * creating proxy dlls
  * ...

Some examples are provided in trunk.

== Other ==

*PE.MemoryStream* (*TPEMemoryStream*) allows to read mapped in-memory executable as simple stream.